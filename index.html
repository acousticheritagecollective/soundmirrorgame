<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PHANTOMS IN THE SKY — Acoustic Heritage Collective</title>
<meta name="description" content="Phantoms in the Sky: an acoustic heritage game. Detect enemy aircraft formations using the Abbott's Cliff Sound Mirror. A game of war without violence.">
<link rel="icon" type="image/x-icon" href="ahc.ico">
<style>
@font-face {
  font-family: 'RAF851';
  src: url('RAF%20851ATH%20Normal.otf') format('opentype');
  font-weight: normal;
}
@font-face {
  font-family: 'RAF851';
  src: url('RAF%20851ATH%20Bold.otf') format('opentype');
  font-weight: bold;
}

*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

:root {
  --bg: #6ba4b8;
  --panel: rgba(90,140,160,0.92);
  --border: #4a8a9e;
  --border-hi: #3a7a8e;
  --text: #e8e0d0;
  --text-dim: #c0d8e0;
  --text-bright: #f5f0e5;
  --accent: #c8102e;
  --accent2: #f5a623;
  --navy: #012169;
  --sky: #6ba4b8;
  --cream: #e8e0d0;
  --danger: #c8102e;
  --warn: #f5a623;
  --gold: #f5a623;
  --font-display: 'RAF851', 'Special Elite', sans-serif;
  --font-mono: 'RAF851', 'IBM Plex Mono', 'Courier New', monospace;
}

html, body { width:100%; height:100%; overflow:hidden; background:var(--bg); color:var(--text); }

body { font-family:var(--font-mono); font-size:12px; }

#game-canvas {
  position:fixed; top:0; left:0; width:100%; height:100%;
  display:block; z-index:0;
}

/* ── OVERLAY SYSTEM ─────────────────────── */
.overlay {
  position:fixed; top:0; left:0; right:0; bottom:0;
  display:flex; flex-direction:column; align-items:center;
  z-index:10; pointer-events:none;
  opacity:0; transition:opacity 0.6s ease;
  overflow-y:auto; padding:30px 0;
}
.overlay.active { opacity:1; pointer-events:auto; }

.panel {
  background: var(--panel);
  border: 1px solid var(--border);
  padding: 28px 36px;
  max-width: 780px; width: 92%;
  text-align: center;
  box-shadow: 0 4px 30px rgba(0,0,0,0.2), 0 0 20px rgba(0,0,0,0.05) inset;
  position: relative;
  flex-shrink: 0;
  margin: auto;
}
.panel::before {
  content:''; position:absolute; top:-1px; left:20%; right:20%; height:2px;
  background: linear-gradient(90deg, transparent, var(--accent), transparent);
}

.panel-title {
  font-family: var(--font-display);
  font-size: 28px; letter-spacing: 8px; color: var(--cream);
  font-weight: bold;
  margin: 8px 0 4px;
}
.panel-sub {
  font-size: 9px; letter-spacing: 6px; color: var(--text-dim);
  text-transform: uppercase;
}
.panel-divider {
  border:none; border-top: 1px solid var(--border);
  margin: 16px 0;
}

.blink { animation: blink 1.8s ease-in-out infinite; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.7} }

.prompt {
  font-size: 12px; color: var(--accent); letter-spacing: 4px;
  margin-top: 24px;
}

/* ── LOADING ─────────────────────────────── */
#loading-log {
  text-align:left; font-size:11px; line-height:1.9; margin:12px 0;
  max-height: 160px; overflow:hidden;
}
#loading-log .done { color: var(--cream); }
#loading-log .pending { color: var(--text-dim); }

.progress-bar {
  width:100%; height:2px; background:rgba(0,0,0,0.15); position:relative; margin-top:16px;
  overflow:hidden;
}
.progress-bar .fill {
  position:absolute; top:0; left:0; height:100%;
  background: linear-gradient(90deg, var(--navy), var(--accent));
  transition: width 0.4s ease;
}

/* ── INSTRUCTIONS ────────────────────────── */
.briefing-section {
  text-align:left; line-height:1.85; font-size:15px; color:var(--cream);
  padding:10px 0;
}
.briefing-label {
  color:var(--accent); font-weight:bold; letter-spacing:1px;
  margin-bottom:6px; font-size:15px;
}
.key-badge {
  display:inline-block; background:rgba(0,0,0,0.15); border:1px solid var(--border);
  padding:1px 8px; color:var(--cream); font-size:14px;
  font-family:var(--font-mono); margin:0 2px; font-weight:bold;
}
.controls-row {
  display:flex; gap:12px; align-items:center; margin:3px 0;
}
.controls-label { color:var(--text-dim); margin-left:8px; }

/* ── WAVE INTRO ──────────────────────────── */
#wave-intro .panel {
  padding: 24px 40px;
  background: rgba(90,140,160,0.95);
}
.wave-number {
  font-family:var(--font-display);
  font-size:38px; letter-spacing:6px; color:var(--cream);
  font-weight:bold;
  margin:6px 0;
}
.wave-name {
  font-size:14px; color:var(--accent); letter-spacing:5px; font-weight:bold;
}
.wave-prepare {
  font-size:9px; color:var(--text-dim); letter-spacing:3px; margin-top:12px;
}

/* ── HUD ─────────────────────────────────── */
#hud {
  position:fixed; top:0; left:0; right:0; z-index:5;
  pointer-events:none; opacity:0; transition:opacity 0.3s;
}
#hud.active { opacity:1; }

.hud-top {
  display:flex; justify-content:space-between; align-items:flex-start;
  padding:14px 20px;
  background:linear-gradient(180deg, rgba(90,140,160,0.85) 0%, transparent 100%);
}
.hud-wave-label { font-size:40px; color:#c8102e; letter-spacing:3px; font-weight:bold; }
.hud-formation-status { font-size:40px; margin-top:4px; }
.hud-formation-status.alert { color:#c8102e; font-weight:bold; }
.hud-formation-status.idle { color:#c8102e; }

.hud-score { font-size:40px; color:#c8102e; letter-spacing:2px; text-align:right; font-weight:bold; }
.hud-score-label { font-size:9px; #c8102e; letter-spacing:3px; text-align:right; }

.hud-center {
  position:absolute; top:12px; left:50%; transform:translateX(-50%);
  text-align:center;
}
.hud-lives { font-size:40px; letter-spacing:5px; }
.hud-lives .on { color:var(--accent); text-shadow:0 0 8px rgba(200,16,46,0.4); }
.hud-lives .off { color:rgba(0,0,0,0.2); }
.hud-streak { font-size:9px; color:#c8102e; letter-spacing:2px; margin-top:3px; }

/* HUD message */
#hud-message {
  position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
  z-index:6; pointer-events:none;
  font-size:14px; font-weight:600; letter-spacing:4px;
  padding:10px 28px;
  background:var(--panel); border:1px solid var(--border);
  opacity:0; transition:opacity 0.2s;
  font-family:var(--font-mono);
}
#hud-message.show { opacity:1; }
#hud-message.detect { color:var(--navy); border-color:var(--sky); }
#hud-message.miss { color:var(--warn); border-color:#d0b880; }
#hud-message.breach { color:var(--accent); border-color:var(--accent); }

/* Horn indicator */
#horn-indicator {
  position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  width:75%; text-align:center; z-index:5;
  pointer-events:none; opacity:0; transition:opacity 0.3s;
}
#horn-indicator.active { opacity:1; }




.horn-angle-readout {
  font-size: 40px;
  font-weight: bold;
  color: black;      /* color interno del texto */
  letter-spacing: 2px;
  margin-top: 10px;

}

/* ── GAME OVER ───────────────────────────── */
.gameover-title {
  font-family:var(--font-display);
  font-size:22px; letter-spacing:8px; color:var(--accent);
  font-weight:bold; margin:8px 0 16px;
}
.stats-grid {
  display:grid; grid-template-columns:1fr 1fr; gap:14px;
  text-align:left; padding:16px 0; margin:8px 0;
  border-top:1px solid var(--border); border-bottom:1px solid var(--border);
}
.stat-label { font-size:9px; color:var(--warn); letter-spacing:2px; font-weight:bold; }
.stat-value { font-size:18px; color:var(--cream); font-weight:bold; }
.stat-value.small { font-size:15px; color:var(--text-dim); font-weight:400; }

.callsign-row {
  display:flex; gap:8px; justify-content:center; margin-top:12px;
}
#callsign-input {
  background:rgba(0,0,0,0.15); border:1px solid var(--border);
  color:var(--cream); font-family:var(--font-mono);
  font-size:14px; padding:8px 12px; width:170px;
  text-align:center; letter-spacing:3px; text-transform:uppercase;
  outline:none; font-weight:bold;
}
#callsign-input:focus { border-color:var(--cream); }
#callsign-input::placeholder { color:rgba(232,224,208,0.35); }

#submit-btn {
  background:var(--navy); border:1px solid var(--navy);
  color:var(--cream); font-family:var(--font-mono);
  font-size:11px; padding:8px 16px; cursor:pointer;
  letter-spacing:2px; transition:all 0.2s; font-weight:bold;
}
#submit-btn:hover { background:var(--accent); border-color:var(--accent); color:#fff; }

/* ── LEADERBOARD ─────────────────────────── */
.lb-title {
  font-family:var(--font-display);
  font-size:20px; letter-spacing:8px; color:var(--cream);
  font-weight:bold; margin:8px 0 16px;
}
.lb-list { border-top:1px solid var(--border); }
.lb-row {
  display:grid; grid-template-columns:28px 1fr 80px 44px;
  padding:7px 4px; border-bottom:1px solid var(--border);
  font-size:12px; align-items:center; color:var(--cream);
}
.lb-row.rank1 { color:var(--warn); font-weight:bold; }
.lb-row.rank2, .lb-row.rank3 { color:var(--cream); }
.lb-rank { font-weight:bold; }
.lb-name { letter-spacing:2px; text-align:left; }
.lb-score { text-align:right; font-weight:bold; }
.lb-wave { text-align:right; font-size:9px; color:var(--text-dim); }
.lb-empty { padding:20px; color:var(--text-dim); font-size:11px; }

/* ── CREDITS BAR ─────────────────────────── */
.credits {
  font-size:8px; color:var(--text-dim); letter-spacing:2px;
  margin-top:16px; padding-top:12px; border-top:1px solid var(--border);
}
.credits a { color:var(--sky); text-decoration:none; }

/* ── DEBUG RADAR MAP ─────────────────────── */
#radar-map {
  position:fixed; top:60px; right:14px; z-index:7;
  width:340px; height:340px;
  pointer-events:none; opacity:0; transition:opacity 0.3s;
}
#radar-map.active { opacity:1; }
#radar-map canvas {
  width:100%; height:100%;
  border:1px solid var(--border);
  border-radius:50%;
  background:rgba(90,140,160,0.85);
}
#radar-label {
  text-align:center; font-size:7px; color:var(--text-dim);
  letter-spacing:2px; margin-top:3px;
}

/* ── PAUSE OVERLAY ───────────────────────── */
#pause-screen {
  position:fixed; top:0; left:0; right:0; bottom:0;
  background:rgba(90,140,160,0.85); z-index:15;
  display:none; flex-direction:column;
  align-items:center; justify-content:center;
  font-family:var(--font-mono);
}
#pause-screen.active { display:flex; }
.pause-title {
  font-family:var(--font-display);
  font-size:28px; letter-spacing:8px; color:var(--cream);
  font-weight:bold;
}
.pause-hint {
  font-size:11px; color:var(--text-dim); letter-spacing:3px; margin-top:16px;
}

/* ── QUIT CONFIRM ────────────────────────── */
#quit-confirm {
  position:fixed; top:0; left:0; right:0; bottom:0;
  background:rgba(90,140,160,0.9); z-index:20;
  display:none; flex-direction:column;
  align-items:center; justify-content:center;
  font-family:var(--font-mono);
}
#quit-confirm.active { display:flex; }
.quit-box {
  background:var(--panel); border:1px solid var(--accent);
  padding:28px 40px; text-align:center;
}
.quit-title { font-size:14px; color:var(--accent); letter-spacing:3px; margin-bottom:16px; font-weight:bold; }
.quit-hint { font-size:11px; color:var(--text-dim); letter-spacing:2px; }
.quit-hint .key-badge { margin:0 4px; }

/* ── CROSSHAIR OVERLAY ────────────────────── */
#horn-overlay {
  position:fixed; top:50%; left:50%; z-index:4;
  transform:translate(-50%, -50%);
  pointer-events:none;
  opacity:0; transition:opacity 0.3s;
}
#horn-overlay.active { opacity:1; }
#horn-overlay svg { display:block; }

/* ── PERSISTENT LOGO ──────────────────────── */
#site-logo {
  position:fixed; bottom:30px; left:14px; z-index:8;
  width:96px; height:auto; opacity:0.8;
  pointer-events:none;
  transition:opacity 0.3s;
}
#site-logo:hover { opacity:0.8; }



/* ── HUD KEYS HINT ───────────────────────── */
.hud-keys {
  position:fixed; bottom:4px; right:12px; z-index:5;
  font-size:8px; color:var(--text-dim); letter-spacing:1px;
  pointer-events:none; opacity:0; transition:opacity 0.3s;
}
.hud-keys.active { opacity:1; }

/* ── RESPONSIVE ──────────────────────────── */
@media (max-width:500px) {
  .panel { padding:20px 18px; }
  .panel-title { font-size:20px; letter-spacing:5px; }
  .wave-number { font-size:28px; }
  .hud-score { font-size:16px; }
  #horn-indicator { width:260px; }
}
</style>
</head>
<body>

<img id="site-logo" src="logo.png" alt="AHC">
<canvas id="game-canvas"></canvas>

<!-- ═══ OVERLAYS ═══ -->

<!-- LOADING -->
<div id="loading-screen" class="overlay active">
  <div class="panel">
    <div class="panel-sub">ACOUSTIC HERITAGE COLLECTIVE</div>
    <div class="panel-title">PHANTOMS IN THE SKY</div>
    <hr class="panel-divider">
    <div id="loading-log"></div>
    <div class="progress-bar"><div class="fill" id="loading-fill"></div></div>
  </div>
</div>

<!-- INSTRUCTIONS -->
<div id="instructions-screen" class="overlay">
  <div class="panel" style="max-width:880px">
    <div class="panel-sub" style="color:var(--warn)">CLASSIFIED — RAF ACOUSTIC DEFENCE</div>
    <div class="panel-title">PHANTOMS IN THE SKY</div>
    <div class="panel-sub">A GAME OF WAR WITHOUT VIOLENCE</div>
    <div class="panel-sub" style="margin-top:6px">ACOUSTIC HERITAGE COLLECTIVE — 2026</div>
    <hr class="panel-divider">

    <div style="margin:8px 0 12px; text-align:center;">
      <img src="home.jpg" alt="Abbott's Cliff Sound Mirror" style="width:100%; max-width:500px; border:1px solid var(--border); opacity:0.85; border-radius:2px;">
    </div>

    <!-- Introduction -->
    <div class="briefing-section" style="font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:13px; line-height:1.6;">
      <div class="briefing-label">◆ INTRODUCTION</div>
      <strong>Phantoms in the Sky</strong> is an acoustic heritage game that recreates the experience of a sound mirror listener operator at Abbot's Cliff, Kent (UK). Built in 1928 as part of Dr. William Sansome Tucker's experimental early warning system, this 6-meter concrete dish could detect aircraft up to 22 miles away—long before the invention of radar.
      <br><br>
      You will defend the English coast across seven historical waves, from the 1920s trials through WWII, the Cold War, and into a speculative 2025 conflict. Unlike traditional war games, survival here depends on <strong>listening</strong>—not destruction, but acute auditory perception and patience.
      <br><br>
      This game is based on rigorous acoustic research by The Acoustic Heritage Collective, who conducted in-situ measurements at Abbot's Cliff in October 2022 and developed auralization models using i-SIMPA acoustic simulation software.
    </div>

    <!-- Historical Images -->
    <div style="display:flex; gap:8px; margin:12px 0; flex-wrap:wrap; justify-content:center;">
      <img src="abbotsclifforiginalimage.webp" alt="Abbot's Cliff 1932" style="height:90px; border:1px solid var(--border); opacity:0.8; border-radius:2px;">
      <img src="2022insiturecordings.jpeg" alt="2022 In-Situ Recordings" style="height:90px; border:1px solid var(--border); opacity:0.8; border-radius:2px;">
      <img src="acousticmodeling.png" alt="Acoustic Modeling" style="height:90px; border:1px solid var(--border); opacity:0.8; border-radius:2px;">
    </div>
    <div style="text-align:center; font-size:8px; color:var(--text-dim); margin-bottom:12px;">
      Left: Abbot's Cliff Sound Mirror, 1932 | Center: Field recordings 2022 | Right: i-SIMPA acoustic simulation
    </div>

    <!-- Mission Briefing -->
    <div class="briefing-section" style="font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:10px; line-height:1.7;">
      <div class="briefing-label">◆ YOUR MISSION</div>
      Enemy formations are approaching across the English Channel. You are the listener operator at Abbot's Cliff Sound Mirror. Your acoustic horn is positioned at the mirror's focal point, where sound waves concentrate and amplify distant aircraft engines.
      <br><br>
      <strong>Objective:</strong> Sweep the horn to find peak engine sound intensity. Detect incoming formations before they breach defensive lines. Each wave represents a different historical period with increasing speed, difficulty, and atmospheric interference.
    </div>

    <!-- Controls Section -->
    <div class="briefing-section" style="border-top:1px solid var(--border); padding-top:12px">
      <div class="briefing-label">◆ CONTROLS</div>
      <div style="font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:10px; line-height:1.9;">
        <div class="controls-row">
          <span class="key-badge">← →</span> or <span class="key-badge">MOUSE</span>
          <span class="controls-label">Rotate horn &amp; view (360°)</span>
        </div>
        <div class="controls-row">
          <span class="key-badge">↑ ↓</span>
          <span class="controls-label" style="margin-left:58px">Adjust vertical pitch</span>
        </div>
        <div class="controls-row">
          <span class="key-badge">SPACE</span>
          <span class="controls-label" style="margin-left:58px">Confirm detection</span>
        </div>
        <div class="controls-row">
          <span class="key-badge">SHIFT</span> + <span class="key-badge">ARROWS</span>
          <span class="controls-label" style="margin-left:15px">Fine adjustment (0.05°)</span>
        </div>
        <div class="controls-row">
          <span class="key-badge">ESC</span>
          <span class="controls-label" style="margin-left:72px">Pause game</span>
        </div>
        <div class="controls-row">
          <span class="key-badge">Q</span>
          <span class="controls-label" style="margin-left:88px">Quit mission</span>
        </div>
      </div>
    </div>

    <!-- Rules of Engagement -->
    <div class="briefing-section" style="border-top:1px solid var(--border); font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:9px; line-height:1.75; padding-top:12px">
      <div class="briefing-label">◆ RULES OF ENGAGEMENT</div>
      • Sweep the acoustic horn slowly to find peak engine sound intensity<br>
      • Press SPACE when aligned—tolerance varies by wave (±1.2° in 1920s, ±0.4° in 2025)<br>
      • 1.5 second cooldown between detection attempts<br>
      • 3 lives per wave—misses and breaches cost a life<br>
      • Detecting at greater distances earns more points (max 1000 pts at 40km)<br>
      • Weather degrades detection: Clear → Overcast → Fog → Storm<br>
      • Aircraft speed increases each wave: 30 m/s (1920s) → 850 m/s (2025)<br>
      • Use the radar display (bottom-right) for tactical awareness
    </div>

    <!-- The Seven Waves -->
    <div class="briefing-section" style="border-top:1px solid var(--border); padding-top:12px; font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:9px; line-height:1.6;">
      <div class="briefing-label">◆ THE SEVEN WAVES</div>
      <strong>Wave 1: 1920s TRIALS</strong> — Experimental biplanes, clear skies (30 m/s)<br>
      <strong>Wave 2: 1939-45 BLITZ</strong> — WWII German bombers, storm conditions (110 m/s)<br>
      <strong>Wave 3: 1950s KOREA</strong> — Early jet age, overcast weather (280 m/s)<br>
      <strong>Wave 4: 1979-89 AFGHAN</strong> — Cold War tactical aircraft, haze (260 m/s)<br>
      <strong>Wave 5: 1982 FALKLANDS</strong> — Subsonic jets, dense fog (300 m/s)<br>
      <strong>Wave 6: 1991 DESERT STORM</strong> — Supersonic fighters, clear skies (650 m/s)<br>
      <strong>Wave 7: 2025 EASTERN FRONT</strong> — Hypersonic threats, severe storm (850 m/s)
    </div>

    <!-- Acoustic Heritage -->
    <div class="briefing-section" style="border-top:1px solid var(--border); padding-top:12px; font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:9px; line-height:1.7;">
      <div class="briefing-label">◆ ACOUSTIC HERITAGE SAFEGUARDING</div>
      This game's audio model is based on authentic acoustic simulations that account for:
      <br>
      • Distance attenuation (inverse square law + atmospheric absorption)<br>
      • Sound mirror physical SPL amplification (+18 dB at focal point)<br>
      • Frequency response of period stethoscopes and trumpet listening devices<br>
      • Historical weather conditions and ambient soundscapes
      <br><br>
      The auralization recreates what operators would have heard in 1928, honoring the acoustic heritage of these monumental "listening ears."
    </div>

    <!-- Credits Brief -->
    <div class="briefing-section" style="border-top:1px solid var(--border); padding-top:12px; font-family: 'IBM Plex Mono', 'Courier New', monospace; font-size:8px; line-height:1.6; color:var(--text-dim);">
      <div class="briefing-label">◆ CREDITS</div>
      <strong>Research & Measurements (2022):</strong> Ginebra Raventós, Ɇ₥łⱠłØ ₥₳ⱤӾ, Edgardo Gómez<br>
      <strong>Acoustic Heritage Collective:</strong> Marx E., Raventós G., Gómez E., Lavandeira J.<br>
      <strong>Acoustic Modeling:</strong> i-SIMPA software (CSTB)<br>
      <strong>Auralization & Game Design:</strong> Ɇ₥łⱠłØ ₥₳ⱤӾ<br>
      <strong>3D Modeling:</strong> Joan Lavandeira
    </div>

    <!-- Start Button -->
    <div style="text-align:center; margin:24px 0 12px;">
      <button id="start-mission-btn" style="
        background: linear-gradient(180deg, var(--accent) 0%, #a00e28 100%);
        border: 2px solid var(--cream);
        color: var(--cream);
        font-family: var(--font-display);
        font-size: 18px;
        font-weight: bold;
        letter-spacing: 4px;
        padding: 16px 48px;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 0 4px 15px rgba(200,16,46,0.4), 0 0 20px rgba(200,16,46,0.2) inset;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      ">
        BEGIN MISSION
      </button>
    </div>
    <div style="text-align:center; font-size:9px; color:var(--text-dim); margin-bottom:8px; font-family: 'IBM Plex Mono', 'Courier New', monospace;">
      (or press SPACE)
    </div>

    <div class="credits">
      ACOUSTIC HERITAGE COLLECTIVE — <a href="https://acousticheritagecollective.org" target="_blank">acousticheritagecollective.org</a>
    </div>
  </div>
</div>

<!-- WAVE INTRO -->
<div id="wave-intro" class="overlay">
  <div class="panel">
    <div class="panel-sub">INCOMING</div>
    <div class="wave-number" id="wave-intro-num">WAVE 1</div>
    <div class="wave-name" id="wave-intro-name">CALM SKIES</div>
    <div class="wave-prepare">PREPARE YOUR EARS</div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-top">
    <div>
      <div class="hud-wave-label" id="hud-wave-label">WAVE 1 — CALM SKIES</div>
      <div class="hud-formation-status idle" id="hud-formation-status">SCANNING...</div>
    </div>
    <div>
      <div class="hud-score" id="hud-score">0</div>
      <div class="hud-score-label">SCORE</div>
    </div>
  </div>
  <div class="hud-center">
    <div class="hud-lives" id="hud-lives">
      <span class="on">♦</span><span class="on">♦</span><span class="on">♦</span>
    </div>
    <div class="hud-streak" id="hud-streak"></div>

  </div>
</div>
<div id="hud-message"></div>
<div id="horn-indicator">
  <div class="horn-bar">
    <div class="center-line"></div>
    <div class="effective-zone" id="horn-zone"></div>
    <div class="needle" id="horn-needle" style="left:50%"></div>
  </div>
  
  <div class="horn-angle-readout" id="horn-readout">HORN: 0.0°</div>

</div>
<div id="cooldown-bar"><div id="cooldown-fill"></div>
</div>

<!-- CROSSHAIR + 3D horn is loaded into the scene -->
<div id="horn-overlay">
  <svg width="24" height="24" viewBox="0 0 24 24">
    <line x1="12" y1="4" x2="12" y2="10" stroke="#c8102e" stroke-width="1" opacity="0.5"/>
    <line x1="12" y1="14" x2="12" y2="20" stroke="#c8102e" stroke-width="1" opacity="0.5"/>
    <line x1="4" y1="12" x2="10" y2="12" stroke="#c8102e" stroke-width="1" opacity="0.5"/>
    <line x1="14" y1="12" x2="20" y2="12" stroke="#c8102e" stroke-width="1" opacity="0.5"/>
  </svg>
</div>

<!-- DEBUG RADAR MAP -->
<div id="radar-map">
  <canvas id="radar-canvas" width="680" height="680"></canvas>
  <div id="radar-label">DEBUG RADAR</div>
</div>

<!-- PAUSE -->
<div id="pause-screen">
  <div class="pause-title">PAUSED</div>
  <div class="pause-hint">PRESS <span class="key-badge">ESC</span> TO RESUME</div>
  <div class="pause-hint" style="margin-top:8px">PRESS <span class="key-badge">Q</span> TO QUIT MISSION</div>
</div>

<!-- QUIT CONFIRM -->
<div id="quit-confirm">
  <div class="quit-box">
    <div class="quit-title">ABORT MISSION?</div>
    <div class="quit-hint">
      <span class="key-badge">Y</span> CONFIRM &nbsp;&nbsp;
      <span class="key-badge">N</span> CANCEL
    </div>
  </div>
</div>

<!-- HUD KEYS HINT -->
<div class="hud-keys" id="hud-keys">← → / MOUSE: HORN · SPACE: DETECT · ESC: PAUSE · Q: QUIT</div>

<!-- GAME OVER -->
<div id="gameover-screen" class="overlay">
  <div class="panel" style="max-width:520px">
    <div class="panel-sub" style="color:var(--warn)">TRANSMISSION ENDED</div>
    <div class="gameover-title">MISSION OVER</div>
    <div class="stats-grid">
      <div><div class="stat-label">FINAL SCORE</div><div class="stat-value" id="go-score">0</div></div>
      <div><div class="stat-label">WAVE REACHED</div><div class="stat-value" id="go-wave">1</div></div>
      <div><div class="stat-label">DETECTIONS</div><div class="stat-value small" id="go-detections">0</div></div>
      <div><div class="stat-label">ACCURACY</div><div class="stat-value small" id="go-accuracy">0%</div></div>
    </div>
    <div id="go-input-section">
      <div style="font-size:10px;color:var(--cream);letter-spacing:2px;margin-bottom:10px">
        ENTER YOUR CALLSIGN FOR THE HONOUR ROLL
      </div>
      <div class="callsign-row">
        <input type="text" id="callsign-input" maxlength="12" placeholder="CALLSIGN" autocomplete="off">
        <button id="submit-btn">SUBMIT</button>
      </div>
    </div>
    <div id="go-submitted" style="display:none">
      <div style="font-size:11px;color:var(--accent);letter-spacing:2px;margin-top:12px">✓ SCORE RECORDED</div>
      <div class="prompt blink" style="margin-top:16px">[ PRESS SPACE FOR HONOUR ROLL ]</div>
    </div>
  </div>
</div>

<!-- LEADERBOARD -->
<div id="leaderboard-screen" class="overlay">
  <div class="panel" style="max-width:520px">
    <div class="panel-sub">TOP LISTENERS</div>
    <div class="lb-title">HONOUR ROLL</div>
    <div class="lb-list" id="lb-list">
      <div class="lb-empty">No scores recorded yet. Be the first!</div>
    </div>
    <div class="prompt blink" style="margin-top:20px">[ PRESS SPACE TO PLAY AGAIN ]</div>
    <div class="credits">
      ACOUSTIC HERITAGE COLLECTIVE — <a href="https://acousticheritagecollective.org" target="_blank">acousticheritagecollective.org</a>
    </div>
  </div>
</div>


<!-- ═══ THREE.JS ═══ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════
//  PHANTOMS IN THE SKY GAME — Standalone
//  Acoustic Heritage Collective, 2026
// ═══════════════════════════════════════════════════════════════

(function() {
"use strict";

// ── CONSTANTS ──────────────────────────────────────────────────
const FIELD_DEPTH   = 40000;    // 40km
const FIELD_WIDTH   = 22000;    // ±22km spawn width (gives ~14° at 40km, within detection range)
const TARGET_WIDTH  = 25000;     // ±3km at y=0
const SPEED         = 60;       // 50 m/s (180 km/h)
const SOURCE_DB     = 140;      // dB @ 1m
const MIRROR_MAX_ANGLE = 30;
const HORN_RANGE    = 30;       // ±15°
const BREACH_ANGLE  = 30;
const BREACH_DIST   = 5000;     // 5km
const MAX_LIVES     = 3;
const BASE_PTS      = 100;
const MISS_COOLDOWN = 1;     // seconds between detection attempts
const MISS_PENALTY  = 50;      // points lost per miss

const MIRROR_GAIN = [
  [0,18],[1,17],[2,16],[3,16],[4,16],[5,15],[6,14],[7,13],
  [8,12],[9,11],[10,10],[11,9],[12,6],[13,3],[14,3],[15,2],[16,0]
];

const WAVES = [
  {n:"1920s TRIALS",       si:8,  mx:2,  w:"clear",         ab:0,  tol:1.2, spd:30,  eng:'engine_1920s.mp3' },
  {n:"1939-45 BLITZ",      si:6,  mx:3,  w:"storm",         ab:5,  tol:1.0, spd:110, eng:'engine_1940s.mp3' },
  {n:"1950s KOREA",        si:5,  mx:3,  w:"overcast",      ab:8,  tol:0.8, spd:280, eng:'engine_1950s.mp3' },
  {n:"1979-89 AFGHAN",     si:4,  mx:3,  w:"haze",          ab:10, tol:0.7, spd:260, eng:'engine_1980s.mp3' },
  {n:"1982 FALKLANDS",     si:3,  mx:3,  w:"fog",           ab:12, tol:0.6, spd:300, eng:'engine_1982.mp3' },
  {n:"1991 DESERT STORM",  si:2,  mx:3,  w:"clear",         ab:15, tol:0.5, spd:650, eng:'engine_1991.mp3' },
  {n:"2025 EASTERN FRONT", si:1.5,mx:3,  w:"storm",         ab:20, tol:0.4, spd:850, eng:'engine_2025.mp3' },
];

function getWave(i) {
  if (i < WAVES.length) return WAVES[i];
  const e = i - WAVES.length + 1;
  return {n:"Endless War "+e, si:Math.max(1,1.5-e*0.1), mx:3,
    w:"storm", ab:25+e, tol:Math.max(0.15, 0.4-e*0.03), spd:850+e*50, eng:'engine_2025.mp3'};
}
function detectionsNeeded(i) { return i<3?3:i<6?4:i<9?5:6; }
function weatherMult(i) { return i<3?1:i<5?1.3:i<7?1.6:i<9?2:3; }

// ── UTILS ──────────────────────────────────────────────────────
function dbGain(db) { return Math.pow(10, db/20); }
function distAtt(d) { return d<1 ? 0 : -20*Math.log10(d); }
function mirrorGain(ang) {
  const a = Math.abs(ang);
  if (a>=MIRROR_MAX_ANGLE) return 0;
  for (let i=0;i<MIRROR_GAIN.length-1;i++) {
    const [a0,g0]=MIRROR_GAIN[i], [a1,g1]=MIRROR_GAIN[i+1];
    if (a>=a0 && a<=a1) { const t=(a-a0)/(a1-a0); return g0+t*(g1-g0); }
  }
  return 0;
}
function formAngle(x,y) { return Math.atan2(x,y)*(180/Math.PI); }
function formDist(x,y) { return Math.sqrt(x*x+y*y); }
function clamp(v,lo,hi) { return Math.max(lo,Math.min(hi,v)); }

// ── DOM HELPERS ────────────────────────────────────────────────
function $(id) { return document.getElementById(id); }
function showOverlay(id) {
  document.querySelectorAll('.overlay').forEach(o => o.classList.remove('active'));
  if (id) $(id).classList.add('active');
}
function showHud(on) {
  $('hud').classList.toggle('active', on);
  $('horn-indicator').classList.toggle('active', on);
  $('radar-map').classList.toggle('active', on);
  $('cooldown-bar').classList.toggle('active', on);
  $('hud-keys').classList.toggle('active', on);
  $('horn-overlay').classList.toggle('active', on);
}

// ── LEADERBOARD (Google Sheets cloud) ─────────────────────────
// STEP 1: Create a Google Sheet with headers: name | score | wave | date
// STEP 2: Go to Extensions → Apps Script, paste the AppsScript.js code
// STEP 3: Deploy as Web App (Anyone can access), copy the URL below:
const LB_API = 'https://script.google.com/macros/s/AKfycbwOoTrAmlpxRWjbfIyZ6GEBr_wjU9bsm-gCZDFZP6LQ6PPFm349urXIXDnU-4oin0kD/exec';

// Local cache + fallback
let _lbCache = [];
let _lbLoaded = false;

async function loadLBRemote() {
  if (LB_API.includes('PASTE_YOUR')) {
    try { _lbCache = JSON.parse(localStorage.getItem('phantoms_lb')) || []; } catch(e) { _lbCache = []; }
    _lbLoaded = true;
    return;
  }
  try {
    const data = await new Promise((resolve) => {
      const cbName = 'phantomsLB_' + Math.random().toString(36).slice(2);
      // Register global callback
      window[cbName] = function(d) {
        resolve(d);
        delete window[cbName];
      };
      // Inject script tag — browser follows redirects for script src natively
      const s = document.createElement('script');
      s.src = LB_API + '?action=read&callback=' + cbName + '&t=' + Date.now();
      s.onload = function() { setTimeout(() => { try { document.head.removeChild(s); } catch(e){} }, 100); };
      s.onerror = function() {
        console.warn('JSONP script load error');
        delete window[cbName];
        resolve(null);
        try { document.head.removeChild(s); } catch(e){}
      };
      document.head.appendChild(s);
      // Timeout
      setTimeout(() => { if (window[cbName]) { delete window[cbName]; resolve(null); } }, 10000);
    });
    if (data && Array.isArray(data)) {
      _lbCache = data;
      try { localStorage.setItem('phantoms_lb', JSON.stringify(_lbCache)); } catch(e) {}
      console.log('Leaderboard loaded from cloud:', _lbCache.length, 'scores');
    } else {
      try { _lbCache = JSON.parse(localStorage.getItem('phantoms_lb')) || []; } catch(e) { _lbCache = []; }
      console.warn('Cloud read failed, using local cache');
    }
  } catch(e) {
    console.warn('LB load error:', e);
    try { _lbCache = JSON.parse(localStorage.getItem('phantoms_lb')) || []; } catch(e2) { _lbCache = []; }
  }
  _lbLoaded = true;
  renderLB();
}

async function addScoreRemote(entry) {
  _lbCache.push(entry);
  _lbCache.sort((a,b) => b.score - a.score);
  _lbCache = _lbCache.slice(0, 50);
  try { localStorage.setItem('phantoms_lb', JSON.stringify(_lbCache)); } catch(e) {}
  if (LB_API.includes('PASTE_YOUR')) return;
  // Write via JSONP
  const cbName = 'phantomsW_' + Math.random().toString(36).slice(2);
  window[cbName] = function() { delete window[cbName]; console.log('Score saved to cloud'); };
  const s = document.createElement('script');
  s.src = LB_API + '?action=write&name=' + encodeURIComponent(entry.name) + '&score=' + entry.score + '&wave=' + entry.wave + '&callback=' + cbName;
  document.head.appendChild(s);
  setTimeout(() => { try { delete window[cbName]; document.head.removeChild(s); } catch(e){} }, 10000);
}

function getTop10() {
  const sorted = [..._lbCache].sort((a,b) => b.score - a.score);
  return sorted.slice(0, 10);
}

function renderLB() {
  const list = $('lb-list');
  const top = getTop10();
  if (!top.length) {
    list.innerHTML = '<div class="lb-empty">No scores recorded yet. Be the first!</div>';
    return;
  }
  list.innerHTML = top.map((e,i) => {
    const cls = i===0?'rank1':i<3?'rank2 rank3':'';
    return `<div class="lb-row ${cls}">
      <div class="lb-rank">${i+1}.</div>
      <div class="lb-name">${e.name}</div>
      <div class="lb-score">${e.score.toLocaleString()}</div>
      <div class="lb-wave">W${e.wave}</div>
    </div>`;
  }).join('');
}

// Load leaderboard on startup
loadLBRemote();


// ═══════════════════════════════════════════════════════════════
//  AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.fBus = null;
    this.nodes = new Map();
    this.ok = false;
    this._sgInt = null;
    this._thTimer = 0;
    this._buffers = {};
    this._currentWxFile = null;
    this._wxSrc = null;
  }

  init() {
    if (this.ok) return;
    this.ctx = new (window.AudioContext||window.webkitAudioContext)();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.75;
    this.master.connect(this.ctx.destination);

    // Formation bus → stethoscope chain → master
    this.fBus = this.ctx.createGain();
    this.fBus.gain.value = 1;

    // Stethoscope: lowpass 1kHz
    this.sLP = this.ctx.createBiquadFilter();
    this.sLP.type='lowpass'; this.sLP.frequency.value=800; this.sLP.Q.value=0.7;

    // Stethoscope: peaking 50Hz +12dB (bass zone 30-120Hz)
    this.sPk1 = this.ctx.createBiquadFilter();
    this.sPk1.type='peaking'; this.sPk1.frequency.value=50;
    this.sPk1.gain.value=12; this.sPk1.Q.value=1;

    // Horn: peaking 50Hz +6dB
    this.sPk2 = this.ctx.createBiquadFilter();
    this.sPk2.type='peaking'; this.sPk2.frequency.value=50;
    this.sPk2.gain.value=12; this.sPk2.Q.value=4;

    this.fBus.connect(this.sLP).connect(this.sPk1).connect(this.sPk2).connect(this.master);

    // Pre-load all MP3 buffers
    this._preloadAll();

    // Init ambient (will start when buffers are ready)
    this._initAmbient();
    this.ok = true;
  }

  async _loadBuffer(url) {
    if (this._buffers[url]) return this._buffers[url];
    try {
      const resp = await fetch(url);
      const ab = await resp.arrayBuffer();
      const buf = await this.ctx.decodeAudioData(ab);
      this._buffers[url] = buf;
      return buf;
    } catch(e) {
      console.warn('Failed to load audio:', url, e);
      return null;
    }
  }

  _preloadAll() {
    // Pre-load all audio files in parallel
    const files = ['fokker.mp3','ambient.mp3','gaviotas.mp3','viento.mp3','lluvia.mp3','tormenta.mp3','truenos.mp3'];
    files.forEach(f => this._loadBuffer(f));
  }

  _initAmbient() {
    // Ambient gain
    this.ambGain = this.ctx.createGain();
    this.ambGain.gain.value = dbGain(50-70);

    // Weather gain
    this.wxGain = this.ctx.createGain();
    this.wxGain.gain.value = 0;

    // Seagull gain
    this.sgGain = this.ctx.createGain();
    this.sgGain.gain.value = 0;
    this.sgGain.connect(this.master);

    // Start ambient MP3 when loaded
    this._loadBuffer('ambient.mp3').then(buf => {
      if (!buf || !this.ctx) return;
      this.ambSrc = this.ctx.createBufferSource();
      this.ambSrc.buffer = buf;
      this.ambSrc.loop = true;
      const lp = this.ctx.createBiquadFilter();
      lp.type='lowpass'; lp.frequency.value=8000; lp.Q.value=0.5;
      this.ambSrc.connect(lp).connect(this.ambGain).connect(this.master);
      this.ambSrc.start();
      console.log('Ambient audio started');
    });
  }

  setWeather(boostDB, weather) {
    if (!this.ctx) return;
    console.log('setWeather called:', {boostDB, weather});
    const t = this.ctx.currentTime;
const wv = boostDB > 0 ? dbGain(boostDB - 30) : 0;
this.wxGain.gain.setTargetAtTime(wv, t, 5);

    // Determine which weather MP3 to play
    let wxFile = null;
    if (weather.includes('thunder') || weather === 'storm') wxFile = 'tormenta.mp3';
    else if (weather.includes('rain')) wxFile = 'lluvia.mp3';
    else if (weather === 'fog') wxFile = 'viento.mp3'; // fog = wind sound
    else if (weather === 'haze') wxFile = 'viento.mp3'; // haze = light wind
    else if (weather === 'overcast') wxFile = 'ambient.mp3'; // overcast = ambient
    else if (weather.includes('wind')) wxFile = 'viento.mp3';
    
    console.log('Weather file determined:', wxFile, 'current:', this._currentWxFile);

    if (wxFile && wxFile !== this._currentWxFile) {
      console.log('Loading new weather file:', wxFile);
      this._currentWxFile = wxFile;
      this._loadBuffer(wxFile).then(buf => {
        if (!buf || !this.ctx) return;
        console.log('Weather buffer loaded, starting playback');
        // Stop previous weather source
        if (this._wxSrc) { try { this._wxSrc.stop(); } catch(e) {} }
        this._wxSrc = this.ctx.createBufferSource();
        this._wxSrc.buffer = buf;
        this._wxSrc.loop = true;
        this._wxSrc.connect(this.wxGain).connect(this.master);
        this._wxSrc.start();
        console.log('Weather audio playing');
      });
    } else if (!wxFile && this._currentWxFile) {
      // No weather — stop weather source
      console.log('Stopping weather audio');
      this._currentWxFile = null;
      if (this._wxSrc) { try { this._wxSrc.stop(); } catch(e) {} this._wxSrc = null; }
    }

    // Seagulls
    if (weather.includes('seagull')) this._startSG();
else { this.sgGain.gain.setTargetAtTime(0, t, 3); this._stopSG(); }
  }

  _startSG() {
    if (this._sgInt) return;
    this._loadBuffer('gaviotas.mp3').then(buf => {
      if (!buf) return;
      const fire = () => {
        if (!this.ctx) return;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        // Random pitch shift for variety
        src.playbackRate.value = 0.8 + Math.random() * 0.4;
        const g = this.ctx.createGain();
        g.gain.value = 0.07;
        src.connect(g).connect(this.sgGain);
        this.sgGain.gain.value = 1;
        src.start();
        this._sgInt = setTimeout(fire, 3000 + Math.random() * 8000);
      };
      fire();
    });
  }
  _stopSG() { if(this._sgInt){clearTimeout(this._sgInt);this._sgInt=null;} }

  thunder() {
    if (!this.ctx) return;
    this._loadBuffer('truenos.mp3').then(buf => {
      if (!buf || !this.ctx) return;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      // Random pitch for variety
      src.playbackRate.value = 0.85 + Math.random() * 0.3;
      const g = this.ctx.createGain();
      g.gain.value = 0.3;
      src.connect(g).connect(this.master);
      src.start();
    });
  }

  // ── Formation audio (engine sounds) ──
  addFormation(id, engineFile) {
    if (!this.ctx) return;
    if (!engineFile) engineFile = 'fokker.mp3'; // fallback
    this._loadBuffer(engineFile).then(buf => {
      if (!buf || !this.ctx) return;
      // Check formation still exists (might have been removed during load)
      if (this.nodes.has(id)) return;

      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      src.loop = true;
      // Slight random detune so overlapping formations sound different
      src.playbackRate.value = 0.85 + Math.random() * 0.14;

      const dg = this.ctx.createGain(); dg.gain.value = 0;
      const dlp = this.ctx.createBiquadFilter(); dlp.type = 'lowpass';
      dlp.frequency.value = 8000; dlp.Q.value = 0.5;
      const mg = this.ctx.createGain(); mg.gain.value = -8;

      src.connect(dg).connect(dlp).connect(mg).connect(this.fBus);
      src.start();

      this.nodes.set(id, {src, dg, dlp, mg});
    });
  }

  updateFormation(id, dist, detAngle) {
    const n = this.nodes.get(id);
    if (!n || !this.ctx) return;
    const t = this.ctx.currentTime;
    // Distance attenuation
    const att = distAtt(dist);
    const lvl = SOURCE_DB + att;
    const dv = Math.max(0, dbGain(lvl - 100));
    n.dg.gain.setTargetAtTime(dv, t, 0.05);
    // Atmospheric lowpass
    const dr = Math.min(dist / FIELD_DEPTH, 1);
    const fc = 8000 - dr * 7500;
    n.dlp.frequency.setTargetAtTime(Math.max(200, fc), t, 0.05);
    // Mirror gain
    const mdb = mirrorGain(detAngle);
    n.mg.gain.setTargetAtTime(dbGain(mdb) * 0.6, t, 0.05);
  }

  removeFormation(id) {
    const n = this.nodes.get(id);
    if (!n) return;
    const t = this.ctx.currentTime;
    n.dg.gain.setTargetAtTime(0, t, 0.1);
    setTimeout(() => {
      try {
        n.src.stop(); n.src.disconnect();
        n.dg.disconnect(); n.dlp.disconnect(); n.mg.disconnect();
      } catch(e) {}
      this.nodes.delete(id);
    }, 300);
  }

  // ── SFX (kept as oscillators — these are UI sounds, not environmental) ──
  sfxDetect() {
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator(); o.type='sine'; o.frequency.value=880;
    const g=this.ctx.createGain(); g.gain.value=0;
    g.gain.setTargetAtTime(0.12,t,0.001); g.gain.setTargetAtTime(0,t+0.15,0.005);
    o.connect(g).connect(this.master); o.start(t); o.stop(t+0.4);
    setTimeout(()=>{
      const o2=this.ctx.createOscillator(); o2.type='sine'; o2.frequency.value=1320;
      const g2=this.ctx.createGain(); g2.gain.value=0;
      const t2=this.ctx.currentTime;
      g2.gain.setTargetAtTime(0.12,t2,0.001); g2.gain.setTargetAtTime(0,t2+0.2,0.005);
      o2.connect(g2).connect(this.master); o2.start(t2); o2.stop(t2+0.5);
    },120);
  }
  sfxMiss() {
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=200;
    o.frequency.setTargetAtTime(100,t,0.15);
    const g=this.ctx.createGain(); g.gain.value=0;
    g.gain.setTargetAtTime(0.1,t,0.005); g.gain.setTargetAtTime(0,t+0.3,0.05);
    o.connect(g).connect(this.master); o.start(t); o.stop(t+0.6);
  }
  sfxBreach() {
    const t=this.ctx.currentTime;
    for(let i=0;i<3;i++){
      const o=this.ctx.createOscillator(); o.type='square'; o.frequency.value=150-i*30;
      const g=this.ctx.createGain(); g.gain.value=0;
      const s=t+i*0.2;
      g.gain.setTargetAtTime(0.1,s,0.005); g.gain.setTargetAtTime(0,s+0.15,0.01);
      o.connect(g).connect(this.master); o.start(s); o.stop(s+0.3);
    }
  }
  sfxGameover() {
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=300;
    o.frequency.linearRampToValueAtTime(50,t+1.5);
    const g=this.ctx.createGain(); g.gain.value=0.04;
    g.gain.setTargetAtTime(0,t+1,0.2);
    o.connect(g).connect(this.master); o.start(t); o.stop(t+2);
  }

  destroy() {
    this._stopSG();
    if (this._wxSrc) { try { this._wxSrc.stop(); } catch(e) {} }
    for(const[id] of this.nodes) this.removeFormation(id);
    if(this.ctx){this.ctx.close();this.ctx=null;}
    this.ok=false;
  }

  muteAll() {
    if (!this.ctx) return;
    if (this.ctx.state === 'running') this.ctx.suspend();
  }

  unmuteAll() {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();
  }

  stopAll() {
    for(const[id] of this.nodes) this.removeFormation(id);
    this._stopSG();
    if (this._wxSrc) { try { this._wxSrc.stop(); } catch(e) {} this._wxSrc = null; this._currentWxFile = null; }
    if (this.ambGain) this.ambGain.gain.value = 0;
    if (this.wxGain) this.wxGain.gain.value = 0;
    if (this.sgGain) this.sgGain.gain.value = 0;
  }
}


// ═══════════════════════════════════════════════════════════════
//  3D SCENE — First-person view from operator position
// ═══════════════════════════════════════════════════════════════
class Scene3D {
  constructor(canvas) {
    this.cv = canvas;
    this.ready = false;
    this.viewAngle = 0; // current horn/view angle in degrees
  }

  init() {
    const T = THREE;
    this.r = new T.WebGLRenderer({canvas:this.cv, antialias:true, alpha:false});
    this.r.setSize(this.cv.clientWidth, this.cv.clientHeight);
    this.r.setPixelRatio(Math.min(window.devicePixelRatio,2));
    this.r.shadowMap.enabled = true;
//    this.r.setClearColor(0x030a14);

    this.sc = new T.Scene();
//    this.sc.fog = new T.FogExp2(0x030a14, 0.00012);


// 360 background
const bgLoader = new T.TextureLoader();
bgLoader.load('bg-eq-1920s.png', (texture) => {
  texture.mapping = T.EquirectangularReflectionMapping;
  texture.colorSpace = T.SRGBColorSpace;
  this.sc.background = texture;
  this.sc.environment = texture;
});


    // Camera = operator's eyes, looking at the mirror
    this.cam = new T.PerspectiveCamera(70, this.cv.clientWidth/this.cv.clientHeight, 0.1, 50000);
    this.camPivot = new T.Group();
    this.camPivot.position.set(0, 3.4, -5.7);
    this.cam.position.set(0, 0, 0);
    this.cam.lookAt(0, 3.4, 40);
    this.camPivot.add(this.cam);
    this.sc.add(this.camPivot);

    // Build mirror
    this._buildMirror(T);

    // Load horn.glb — attached to camera (fixed on screen like FPS weapon)
    this._loadHorn();

    // Lights
    this.sc.add(new T.AmbientLight(0x3a5570, 0.4));
    const dl = new T.DirectionalLight(0xffeedd, 0.7);
    dl.position.set(-15, 25, 10); dl.castShadow=true; this.sc.add(dl);
    const rl = new T.DirectionalLight(0x6a90b4, 0.25);
    rl.position.set(10, 5, -10); this.sc.add(rl);



    this.ready = true;
  }

_buildMirror(T) {
  const g = new T.Group();

  // --- Bloque de hormigón ---
  const cMat = new T.MeshStandardMaterial({ color: 0x787868, roughness: 0.95, metalness: 0 });
  const block = new T.Mesh(new T.BoxGeometry(7.2, 7.8, 3.8), cMat);
  block.position.y = 3.9;
  block.castShadow = true;
  block.receiveShadow = true;
  g.add(block);

  // --- Front mirror con textura ---
const loader = new T.TextureLoader();
loader.load('frontmirror_1920s.png', (texture) => {
  const mirrorMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide
  });

  // Evitar z-fighting
  mirrorMat.polygonOffset = true;
  mirrorMat.polygonOffsetFactor = -1;
  mirrorMat.polygonOffsetUnits = -1;

  const mirrorPlane = new THREE.Mesh(new THREE.PlaneGeometry(7.2, 7.8), mirrorMat);

  // Posición: ligeramente delante de la cara del bloque
  mirrorPlane.position.set(0, 4.2, -1.95); // z menor que la cara del bloque (-1.9)

  g.add(mirrorPlane);
  
  // Store references for updates
  this.mirrorMat = mirrorMat;
  this.mirrorPlane = mirrorPlane;
});

  // Inclinación ligera del grupo si quieres
  g.rotation.x = -5 * (Math.PI / 180);
  g.position.set(0, 0, 0);

  // Añadir grupo a la escena
  this.sc.add(g);
}


  _loadHorn() {
    const loader = new THREE.GLTFLoader();
    loader.load('horn.glb', (gltf) => {
      this.hornModel = gltf.scene;
      
      const box = new THREE.Box3().setFromObject(this.hornModel);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      
      // Wrap in a group so we can center the geometry first
      const hornGroup = new THREE.Group();
      
      // Offset model so its center is at origin of the group
      this.hornModel.position.set(0, 0, -5);
//this.hornModel.position.set(-center.x, -center.y, center.z);

      hornGroup.add(this.hornModel);
      
      // Scale: model is ~6 long, we want ~2.5 units in view
      const maxDim = Math.max(size.x, size.y, size.z);
      const s = 32 / maxDim;
      hornGroup.scale.set(s, s, s);
      
      // Rotate: long axis is X, rotate so it points up (Z rotation)
      // Then tilt it slightly forward so it angles towards the mirror
      hornGroup.rotation.set(
        Math.PI / 2.5,             // tilt forward (towards mirror above)
        0,               // no yaw
        Math.PI / 2      // X axis → up
      );
      
      // Position in camera space: x=0 centered, y=up, -z=forward
      hornGroup.position.set(0, -3, -8);
      
      // Disable fog, ensure always visible
      this.hornModel.traverse(child => {
        if (child.isMesh && child.material) {
          const mats = Array.isArray(child.material) ? child.material : [child.material];
          mats.forEach(m => { m.fog = false; m.depthTest = false; });
          child.renderOrder = 999;
        }
      });
      
      this.hornGroup = hornGroup;
      this.cam.add(hornGroup);
      
      const hornLight = new THREE.PointLight(0xffeedd, 1.0, 8);
      hornLight.position.set(0, 1, -2);
      this.cam.add(hornLight);
      
      console.log('Horn loaded — centered, size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));
    }, undefined, (err) => {
      console.warn('Could not load horn.glb:', err);
    });
  }

  setViewAngle(yaw, pitch) {
    // Yaw = horizontal rotation (left/right), affects detection
    // Pitch = vertical look (up/down), purely visual
    this.viewAngle = yaw;
    if (this.camPivot) {
      this.camPivot.rotation.y = -yaw * (Math.PI / 180);
      // Clamp pitch to ±60° so you can look up/down but not flip
      const p = Math.max(-90, Math.min(90, pitch || 0));
      this.camPivot.rotation.x = p * (Math.PI / 180);
    }
  }

  resize() {
    if(!this.r) return;
    const w=this.cv.clientWidth, h=this.cv.clientHeight;
    this.r.setSize(w,h);
    this.cam.aspect=w/h; this.cam.updateProjectionMatrix();
  }
  
  updateWave(waveNum) {
    console.log('updateWave called for wave:', waveNum);
    const mirrorFiles = ['frontmirror_1920s.png','frontmirror_1940s.png','frontmirror_1950s.png','frontmirror_1980s.png','frontmirror_1982.png','frontmirror_1991.png','frontmirror_2025.png'];
    const bgEquirectangularFiles = ['bg-eq-1920s.png', 'bg-eq-1940s.png', 'bg-eq-1950s.png', 'bg-eq-1980s.png', 'bg-eq-1982.png', 'bg-eq-1991.png', 'bg-eq-2025.png'];
    const skyColors = [0xc8d4dc, 0x6a7a8a, 0x9aaaBA, 0xe4d4b4, 0x8a9aaa, 0xffd4a4, 0x5a6a7a];
    const fogDensities = [0.00012, 0.00045, 0.00025, 0.00030, 0.00055, 0.00015, 0.00050];

    
    if(waveNum < mirrorFiles.length && this.mirrorMat) {
      console.log('Updating mirror texture to:', mirrorFiles[waveNum]);
      const T = THREE;
      const loader = new T.TextureLoader();
      loader.load(mirrorFiles[waveNum], (texture) => {
        this.mirrorMat.map = texture;
        this.mirrorMat.needsUpdate = true;
        console.log('Mirror texture updated successfully');
      }, undefined, (err) => {
        console.warn('Failed to load mirror texture:', mirrorFiles[waveNum], err);
      });
    } else {
      console.warn('Cannot update mirror - mirrorMat not ready or invalid wave:', waveNum, 'mirrorMat exists:', !!this.mirrorMat);
    }
    
// REEMPLAZAR TODO ESTE BLOQUE:
if(waveNum < bgEquirectangularFiles.length) {
  console.log('Updating equirectangular background to:', bgEquirectangularFiles[waveNum]);
  const T = THREE;
  const loader = new T.TextureLoader();
  loader.load(bgEquirectangularFiles[waveNum], (texture) => {
    texture.mapping = T.EquirectangularReflectionMapping;
    texture.colorSpace = T.SRGBColorSpace;
    if(this.sc.background) {
      this.sc.background.dispose();
    }
    this.sc.background = texture;
    this.sc.environment = texture;
    console.log('Equirectangular background updated successfully');
  }, undefined, (err) => {
    console.warn('Failed to load background texture:', bgEquirectangularFiles[waveNum], err);
  });
}


    if(waveNum < skyColors.length && this.sky) {
      console.log('Updating sky color to:', skyColors[waveNum].toString(16));
      this.sky.material.color.setHex(skyColors[waveNum]);
    } else {
      console.warn('Cannot update sky - sky not ready');
    }
    
    if(waveNum < fogDensities.length && this.sc.fog) {
      console.log('Updating fog density to:', fogDensities[waveNum]);
      this.sc.fog.density = fogDensities[waveNum];
    } else {
      console.warn('Cannot update fog - fog not ready');
    }
  }

  render() {
    if(this.r && this.sc && this.cam) this.r.render(this.sc, this.cam);
  }
}


// ═══════════════════════════════════════════════════════════════
//  GAME CONTROLLER
// ═══════════════════════════════════════════════════════════════

const audio = new AudioEngine();
const canvas = $('game-canvas');
const scene = new Scene3D(canvas);

let phase = 'loading'; // loading, instructions, wave_intro, playing, gameover, leaderboard
let state = null;
let msgTimeout = null;

// ── HUD updates ──
function updateHUD() {
  if (!state) return;
  const w = getWave(state.wave);
  $('hud-wave-label').textContent = `WAVE ${state.wave+1} — ${w.n.toUpperCase()}`;

  const active = state.formations.filter(f => !f.detected).length;
  const fs = $('hud-formation-status');
  if (active > 0) {
    fs.textContent = `${active} FORMATION${active>1?'S':''} APPROACHING`;
    fs.className = 'hud-formation-status alert';
  } else {
    fs.textContent = 'SCANNING...';
    fs.className = 'hud-formation-status idle';
  }

  $('hud-score').textContent = state.score.toLocaleString();

  // Lives
  let lh = '';
  for (let i=0;i<MAX_LIVES;i++) lh += `<span class="${i<state.lives?'on':'off'}">♦</span>`;
  $('hud-lives').innerHTML = lh;

  // Horn — map to full ±180° range, show effective zone
  const pct = 50 + (state.hornAngle / 180) * 50;
  $('horn-needle').style.left = pct + '%';
  const inRange = Math.abs(state.hornAngle) <= HORN_RANGE;
  $('horn-readout').textContent = `HORN: ${state.hornAngle.toFixed(1)}°${inRange ? '' : '  ⚠ OUT OF RANGE'}`;
  $('horn-readout').style.color = inRange ? '' : '#aa5555';
}

function showMsg(text, type, dur) {
  const el = $('hud-message');
  el.textContent = text;
  el.className = 'show ' + type;
  if (msgTimeout) clearTimeout(msgTimeout);
  msgTimeout = setTimeout(() => { el.className=''; }, dur||2500);
}

// ── LOADING ──
async function doLoad() {
  const log = $('loading-log');
  const fill = $('loading-fill');
  let step = 0;
  const total = 5;

  function addLog(msg, done) {
    const div = document.createElement('div');
    div.className = done ? 'done' : 'pending';
    div.textContent = msg;
    log.appendChild(div);
    step++;
    fill.style.width = Math.round((step/total)*100)+'%';
  }

  addLog('Initializing audio engine...', false);
  await new Promise(r => setTimeout(r, 200));

  addLog('Loading Three.js renderer...', false);
  await new Promise(r => setTimeout(r, 100));

  addLog('Building 3D scene & sound mirror model...', false);
  scene.init();
  addLog('3D scene ready ✓', true);

  addLog('All systems nominal ✓', true);
  fill.style.width = '100%';

  await new Promise(r => setTimeout(r, 600));
  phase = 'instructions';
  showOverlay('instructions-screen');
}

// ── START GAME ──
function startGame() {
  // Init audio on first user interaction
  audio.init();

  state = {
    wave: 0, score: 0, lives: MAX_LIVES,
    formations: [], nextId: 0, lastSpawn: 0,
    waveDet: 0, totalDet: 0, totalAtt: 0,
    hornAngle: 0, viewPitch: 0, over: false, thunderT: 0,
    lastAttemptTime: 0,
    paused: false,
    quitConfirm: false,
  };

  showWaveIntro();
}

function showWaveIntro() {
  const w = getWave(state.wave);
  state.lives = MAX_LIVES; // Reset 3 lives each wave
  $('wave-intro-num').textContent = `WAVE ${state.wave+1}`;
  $('wave-intro-name').textContent = w.n.toUpperCase();
  phase = 'wave_intro';
  showOverlay('wave-intro');
  showHud(true);
  updateHUD();
  
  // Update visuals for this wave
  scene.updateWave(state.wave);

  setTimeout(() => {
    if (phase === 'wave_intro' && state && !state.over) {
      phase = 'playing';
      showOverlay(null);

      // Spawn first formation immediately
      const id = state.nextId++;
      const sx = (Math.random()*2-1)*FIELD_WIDTH;
      const ex = (Math.random()*2-1)*TARGET_WIDTH;
      const td = Math.sqrt((ex-sx)**2 + FIELD_DEPTH**2);
      state.formations.push({id, x:sx, y:FIELD_DEPTH, sx, sy:FIELD_DEPTH, ex, ey:0, spd:w.spd, detected:false, td, tr:0});
      audio.addFormation(id, w.eng);
      state.lastSpawn = performance.now()/1000;
      lastT = 0; // reset dt calculation
      updateHUD();
    }
  }, 3000);
}

// ── END GAME ──
function endGame() {
  state.over = true;
  state.paused = false;
  state.quitConfirm = false;
  $('pause-screen').classList.remove('active');
  $('quit-confirm').classList.remove('active');

  // Resume audio context if suspended, then stop all game audio
  audio.unmuteAll();
  audio.stopAll();
  audio.sfxGameover();

  const acc = state.totalAtt>0 ? Math.round(state.totalDet/state.totalAtt*100) : 0;
  $('go-score').textContent = state.score.toLocaleString();
  $('go-wave').textContent = state.wave+1;
  $('go-detections').textContent = state.totalDet;
  $('go-accuracy').textContent = acc+'%';

  $('go-input-section').style.display = '';
  $('go-submitted').style.display = 'none';
  $('callsign-input').value = '';

  // Store for submit
  state._goData = {score:state.score, wave:state.wave+1, det:state.totalDet, acc};

  phase = 'gameover';
  showOverlay('gameover-screen');
  showHud(false);
  renderLB();

  setTimeout(() => $('callsign-input').focus(), 400);
}

// ── SUBMIT SCORE ──
function submitScore() {
  const name = $('callsign-input').value.replace(/[^a-zA-Z0-9\s\-_]/g,'').trim().toUpperCase().slice(0,12);
  if (!name || !state || !state._goData) return;
  addScoreRemote({
    name, score:state._goData.score, wave:state._goData.wave,
    detections:state._goData.det, accuracy:state._goData.acc, time:Date.now()
  });
  $('go-input-section').style.display = 'none';
  $('go-submitted').style.display = '';
  renderLB();
}

// ── DETECTION ATTEMPT ──
function attemptDetection() {
  if (!state || phase !== 'playing' || state.paused) return;

  // Cooldown check
  const now = performance.now() / 1000;
  const elapsed = now - state.lastAttemptTime;
  if (elapsed < MISS_COOLDOWN) {
    // Still on cooldown — show remaining time
    showMsg(`⏳ COOLDOWN — ${(MISS_COOLDOWN - elapsed).toFixed(1)}s`, 'miss', 800);
    return;
  }
  state.lastAttemptTime = now;

  state.totalAtt++;
  const w = getWave(state.wave);
  const tol = w.tol;

  let best = null, bestDiff = Infinity;
  for (const f of state.formations) {
    if (f.detected) continue;
    const fa = formAngle(f.x, f.y);
    // Formation must be within mirror effective range (±16°) to be detectable at all
    if (Math.abs(fa) > MIRROR_MAX_ANGLE) continue;
    const diff = Math.abs(fa - state.hornAngle);
    if (diff < bestDiff) { bestDiff = diff; best = f; }
  }

  if (best && bestDiff <= tol) {
    // HIT — remove formation immediately
    best.detected = true;
    state.totalDet++;
    state.waveDet++;

    const dist = formDist(best.x, best.y);
    const distM = dist / 10000;
    const wM = weatherMult(state.wave);
    const pts = Math.round(BASE_PTS * distM * wM);
    state.score += pts;

    // Kill audio and remove from formations array immediately
    audio.removeFormation(best.id);
    const idx = state.formations.indexOf(best);
    if (idx !== -1) state.formations.splice(idx, 1);

    audio.sfxDetect();
    showMsg(`✓ FORMATION DETECTED — +${pts} pts`, 'detect');
    updateHUD();

    // Wave advance?
    if (state.waveDet >= detectionsNeeded(state.wave)) {
      state.wave++;
      state.waveDet = 0;
      showWaveIntro();
    }
  } else {
    // MISS — lose a life
    state.lives--;
    const penalty = Math.min(state.score, MISS_PENALTY);
    state.score -= penalty;

    audio.sfxMiss();

    if (state.lives <= 0) {
      showMsg('✗ MISSED — NO LIVES LEFT', 'breach');
      endGame();
      return;
    }
    showMsg(`✗ MISSED ANGLE — LIFE LOST (-${penalty} pts) — ${state.lives} left`, 'miss');
    updateHUD();
  }
}

// ── PAUSE / QUIT ──
function togglePause() {
  if (!state || state.over) return;
  if (state.quitConfirm) return;
  if (phase === 'wave_intro') return;
  if (phase !== 'playing' && !state.paused) return;

  state.paused = !state.paused;
  $('pause-screen').classList.toggle('active', state.paused);
  if (state.paused) {
    audio.muteAll();
  } else {
    audio.unmuteAll();
  }
}

function showQuitConfirm() {
  if (!state || state.over) return;
  state.quitConfirm = true;
  if (!state.paused) {
    state.paused = true;
    audio.muteAll();
  }
  $('pause-screen').classList.remove('active');
  $('quit-confirm').classList.add('active');
}

function confirmQuit(yes) {
  state.quitConfirm = false;
  $('quit-confirm').classList.remove('active');
  if (yes) {
    endGame();
  } else {
    // Return to pause screen
    $('pause-screen').classList.add('active');
  }
}

// ── RADAR MAP ──
const radarCanvas = $('radar-canvas');
const rctx = radarCanvas.getContext('2d');

function drawRadar() {
  if (!state) return;
  const w = 680, h = 680, cx = w/2, cy = h/2, R = w/2 - 16;
  rctx.clearRect(0, 0, w, h);

  // Clip to circle
  rctx.save();
  rctx.beginPath(); rctx.arc(cx, cy, R+2, 0, Math.PI*2); rctx.clip();

  // Background
  rctx.fillStyle = 'rgba(1,20,50,0.92)';
  rctx.fillRect(0, 0, w, h);

  // Range rings
  rctx.strokeStyle = 'rgba(107,164,184,0.25)';
  rctx.lineWidth = 1;
  for (let i = 1; i <= 4; i++) {
    const rr = R * (i/4);
    rctx.beginPath(); rctx.arc(cx, cy, rr, 0, Math.PI*2); rctx.stroke();
  }

  // Range labels
  rctx.fillStyle = 'rgba(107,164,184,0.4)';
  rctx.font = '14px monospace';
  rctx.textAlign = 'center';
  for (let i = 1; i <= 4; i++) {
    rctx.fillText((i*10)+'km', cx+20, cy - R*(i/4) + 14);
  }

  // Cross hairs
  rctx.strokeStyle = 'rgba(107,164,184,0.15)';
  rctx.lineWidth = 0.5;
  rctx.beginPath(); rctx.moveTo(cx, cy-R); rctx.lineTo(cx, cy+R); rctx.stroke();
  rctx.beginPath(); rctx.moveTo(cx-R, cy); rctx.lineTo(cx+R, cy); rctx.stroke();

  // Angle reference lines every 5°
  rctx.strokeStyle = 'rgba(107,164,184,0.1)';
  rctx.lineWidth = 0.5;
  for (let deg = -30; deg <= 30; deg += 5) {
    if (deg === 0) continue;
    const a = (-90 + deg) * Math.PI / 180;
    rctx.beginPath();
    rctx.moveTo(cx, cy);
    rctx.lineTo(cx + Math.cos(a)*R, cy + Math.sin(a)*R);
    rctx.stroke();
  }

  // Angle labels at edge
  rctx.fillStyle = 'rgba(107,164,184,0.4)';
  rctx.font = '11px monospace';
  for (let deg = -30; deg <= 30; deg += 10) {
    const a = (-90 + deg) * Math.PI / 180;
    const lx = cx + Math.cos(a)*(R+1) * 0.92;
    const ly = cy + Math.sin(a)*(R+1) * 0.92;
    rctx.fillText(deg+'°', lx, ly);
  }

  // Breach zone boundary (±30°) — red lines
  rctx.strokeStyle = '#3a1a1a';
  rctx.lineWidth = 2;
  for (const sign of [-1, 1]) {
    const a = (-90 + sign * BREACH_ANGLE) * Math.PI / 180;
    rctx.beginPath();
    rctx.moveTo(cx, cy);
    rctx.lineTo(cx + Math.cos(a)*R, cy + Math.sin(a)*R);
    rctx.stroke();
  }

  // Mirror effective zone (±16°) — filled
  rctx.fillStyle = 'rgba(1,33,105,0.06)';
  const maRad = MIRROR_MAX_ANGLE * Math.PI / 180;
  rctx.beginPath();
  rctx.moveTo(cx, cy);
  rctx.arc(cx, cy, R, -Math.PI/2 - maRad, -Math.PI/2 + maRad);
  rctx.closePath();
  rctx.fill();
  // Mirror zone border
  rctx.strokeStyle = 'rgba(1,33,105,0.3)';
  rctx.lineWidth = 1;
  for (const sign of [-1, 1]) {
    const a = (-90 + sign * MIRROR_MAX_ANGLE) * Math.PI / 180;
    rctx.beginPath(); rctx.moveTo(cx, cy);
    rctx.lineTo(cx + Math.cos(a)*R, cy + Math.sin(a)*R);
    rctx.stroke();
  }

  // 5km breach distance ring
  const br5 = (BREACH_DIST / FIELD_DEPTH) * R;
  rctx.strokeStyle = 'rgba(180,60,60,0.3)';
  rctx.lineWidth = 1;
  rctx.setLineDash([4,4]);
  rctx.beginPath(); rctx.arc(cx, cy, br5, 0, Math.PI*2); rctx.stroke();
  rctx.setLineDash([]);
  rctx.fillStyle = '#aa5555';
  rctx.font = '10px monospace';
  rctx.fillText('5km', cx + br5 + 4, cy - 2);

  // Scanning beam (horn angle ±tolerance)
  const waveDef = getWave(state.wave);
  const hornRad = state.hornAngle * Math.PI / 180;
  const beamAngle = -Math.PI/2 + hornRad;
  const tolRad = waveDef.tol * Math.PI / 180;
  // Tolerance cone
  rctx.fillStyle = 'rgba(107,164,184,0.1)';
  rctx.beginPath();
  rctx.moveTo(cx, cy);
  rctx.arc(cx, cy, R, beamAngle - tolRad, beamAngle + tolRad);
  rctx.closePath();
  rctx.fill();
  // Beam center line
  rctx.strokeStyle = 'rgba(107,164,184,0.6)';
  rctx.lineWidth = 2;
  rctx.beginPath();
  rctx.moveTo(cx, cy);
  rctx.lineTo(cx + Math.cos(beamAngle)*R, cy + Math.sin(beamAngle)*R);
  rctx.stroke();

  // Formations — POLAR mapping: angle → angular position, distance → radial position
  for (const f of state.formations) {
    const dist = formDist(f.x, f.y);
    const ang = formAngle(f.x, f.y); // degrees

    // Map to radar: angle from top (0° = up), distance normalized to FIELD_DEPTH
    const radarAngle = (-90 + ang) * Math.PI / 180; // convert to canvas angle
    const radarDist = Math.min(dist / FIELD_DEPTH, 1) * R;

    const px = cx + Math.cos(radarAngle) * radarDist;
    const py = cy + Math.sin(radarAngle) * radarDist;

    if (f.detected) {
      // Detected: dim sky blue
      rctx.fillStyle = 'rgba(107,164,184,0.4)';
      rctx.beginPath(); rctx.arc(px, py, 5, 0, Math.PI*2); rctx.fill();
    } else {
      // Active: bright red blip
      rctx.fillStyle = '#cc4444';
      rctx.beginPath(); rctx.arc(px, py, 6, 0, Math.PI*2); rctx.fill();
      // Glow
      rctx.fillStyle = 'rgba(220,60,60,0.25)';
      rctx.beginPath(); rctx.arc(px, py, 14, 0, Math.PI*2); rctx.fill();

      // Angle line from center
      rctx.strokeStyle = 'rgba(200,80,80,0.12)';
      rctx.lineWidth = 0.5;
      rctx.beginPath(); rctx.moveTo(cx,cy); rctx.lineTo(px,py); rctx.stroke();

      // Distance + angle label
      rctx.fillStyle = '#aa5555';
      rctx.font = '12px monospace';
      rctx.textAlign = 'left';
      rctx.fillText(`${(dist/1000).toFixed(1)}km`, px+12, py-4);
      rctx.fillText(`${ang.toFixed(1)}°`, px+12, py+10);
    }
  }

  // Mirror position (center dot)
  rctx.fillStyle = '#012169';
  rctx.beginPath(); rctx.arc(cx, cy, 5, 0, Math.PI*2); rctx.fill();
  rctx.fillStyle = '#012169';
  rctx.font = '10px monospace';
  rctx.textAlign = 'center';
  rctx.fillText('MIRROR', cx, cy+16);

  rctx.restore();
}

// ── COOLDOWN BAR ──
function updateCooldownBar() {
  if (!state) return;
  const now = performance.now() / 1000;
  const elapsed = now - state.lastAttemptTime;
  const ratio = Math.min(elapsed / MISS_COOLDOWN, 1);
  $('cooldown-fill').style.transform = `scaleX(${ratio})`;
  $('cooldown-fill').style.background = ratio >= 1 ? 'var(--accent)' : '#8a6a3a';
}

// ── MAIN LOOP ──
let lastT = 0;

function gameLoop(now) {
  requestAnimationFrame(gameLoop);

  // Always render 3D
  if (scene.ready) scene.render();

  // Update cooldown bar when playing (even when paused so you can see it)
  if (state && (phase === 'playing' || phase === 'wave_intro')) {
    updateCooldownBar();
    drawRadar();
  }

  if (phase !== 'playing' || !state || state.over || state.paused) return;

  const t = now / 1000;
  if (lastT === 0) lastT = t;
  const dt = Math.min(t - lastT, 0.1);
  lastT = t;

  const w = getWave(state.wave);

  // ── Spawn ──
  const activeCount = state.formations.filter(f => !f.detected).length;
  if (t - state.lastSpawn >= w.si && activeCount < w.mx) {
    const id = state.nextId++;
    const sx = (Math.random()*2-1)*FIELD_WIDTH;
    const ex = (Math.random()*2-1)*TARGET_WIDTH;
    const td = Math.sqrt((ex-sx)**2 + FIELD_DEPTH**2);
    state.formations.push({id, x:sx, y:FIELD_DEPTH, sx, sy:FIELD_DEPTH, ex, ey:0, spd:w.spd, detected:false, td, tr:0});
    audio.addFormation(id, w.eng);
    state.lastSpawn = t;
  }

  // ── Update formations ──
  for (let i=state.formations.length-1; i>=0; i--) {
    const f = state.formations[i];
    f.tr += f.spd * dt;
    const p = Math.min(f.tr / f.td, 1);
    f.x = f.sx + (f.ex - f.sx) * p;
    f.y = f.sy + (f.ey - f.sy) * p;

    const dist = formDist(f.x, f.y);
    const fa = formAngle(f.x, f.y);
    const da = fa - state.hornAngle;

    audio.updateFormation(f.id, dist, da);

    // Breach check
    if (!f.detected && (dist < BREACH_DIST || Math.abs(fa) > BREACH_ANGLE || f.y <= 0)) {
      state.lives--;
      audio.sfxBreach();
      audio.removeFormation(f.id);
      state.formations.splice(i, 1);
      if (state.lives <= 0) {
        showMsg('⚠ BREACH — NO LIVES LEFT', 'breach');
        endGame(); return;
      }
      showMsg(`⚠ BREACH — LIFE LOST — ${state.lives} left`, 'breach');
      updateHUD();
      continue;
    }
  }

  // Weather
  audio.setWeather(w.ab, w.w);

  // Thunder
  if (w.w.includes('thunder')) {
    state.thunderT -= dt;
    if (state.thunderT <= 0) { audio.thunder(); state.thunderT = 8+Math.random()*15; }
  }

  // Draw radar & update HUD
  updateHUD();
}

// ── INPUT ──
window.addEventListener('keydown', function(e) {
  // ── QUIT CONFIRM takes priority ──
  if (state && state.quitConfirm) {
    if (e.code === 'KeyY') { confirmQuit(true); return; }
    if (e.code === 'KeyN' || e.code === 'Escape') { confirmQuit(false); return; }
    return; // block all other input
  }

  // ── PAUSE ──
  if (e.code === 'Escape') {
    e.preventDefault();
    if (phase === 'playing' || (state && state.paused)) {
      togglePause();
    }
    return;
  }

  // ── QUIT ──
  if (e.code === 'KeyQ') {
    // From leaderboard or gameover-submitted → back to instructions
    if (phase === 'leaderboard') {
      phase = 'instructions';
      showOverlay('instructions-screen');
      showHud(false);
      return;
    }
    if (phase === 'gameover' && $('go-submitted').style.display !== 'none') {
      phase = 'instructions';
      showOverlay('instructions-screen');
      showHud(false);
      return;
    }
    // From playing → pause + quit confirm
    if (state && state.paused && !state.quitConfirm) {
      showQuitConfirm();
    } else if (state && phase === 'playing' && !state.paused) {
      togglePause();
      showQuitConfirm();
    }
    return;
  }

  // ── Block input while paused ──
  if (state && state.paused) return;

  if (e.code === 'Space') {
    e.preventDefault();
    if (phase === 'instructions') { startGame(); return; }
    if (phase === 'playing') { attemptDetection(); return; }
    if (phase === 'gameover') {
      // If submitted, go to leaderboard
      if ($('go-submitted').style.display !== 'none') {
        phase = 'leaderboard';
        showOverlay('leaderboard-screen');
        renderLB();
      }
      return;
    }
    if (phase === 'leaderboard') { startGame(); return; }
  }

  if (e.code === 'Enter' && phase === 'gameover') {
    submitScore();
    return;
  }

  if (state && phase === 'playing') {
    // Arrow keys = move horn/view together — 0.2° per step (fine: 0.05°)
    const step = e.shiftKey ? 0.05 : 0.2;
    if (e.code === 'ArrowLeft') {
      state.hornAngle -= step;
      scene.setViewAngle(state.hornAngle, state.viewPitch);
    }
    if (e.code === 'ArrowRight') {
      state.hornAngle += step;
      scene.setViewAngle(state.hornAngle, state.viewPitch);
    }
    if (e.code === 'ArrowUp') {
      state.viewPitch = Math.min(90, state.viewPitch + step * 3);
      scene.setViewAngle(state.hornAngle, state.viewPitch);
    }
    if (e.code === 'ArrowDown') {
      state.viewPitch = Math.max(-90, state.viewPitch - step * 3);
      scene.setViewAngle(state.hornAngle, state.viewPitch);
    }
  }
});

// Mouse control — pointer lock for unlimited rotation
// Click on canvas to lock, ESC unlocks (handled by browser)
const MOUSE_SENSITIVITY = 0.06; // degrees per pixel
const MOUSE_SENSITIVITY_Y = 0.04;

canvas.addEventListener('click', function() {
  if (phase === 'playing' && !state.paused) {
    canvas.requestPointerLock();
  }
});

window.addEventListener('mousemove', function(e) {
  if (!state || phase !== 'playing' || state.paused) return;
  // movementX/Y work both with and without pointer lock
  // but pointer lock gives unlimited movement (no screen edge)
  const dx = e.movementX || 0;
  const dy = e.movementY || 0;
  state.hornAngle += dx * MOUSE_SENSITIVITY;
  state.viewPitch = Math.max(-90, Math.min(90, state.viewPitch - dy * MOUSE_SENSITIVITY_Y));
  scene.setViewAngle(state.hornAngle, state.viewPitch);
});

// Submit button
$('submit-btn').addEventListener('click', submitScore);

// Start Mission button
document.addEventListener('DOMContentLoaded', function() {
  const startBtn = document.getElementById('start-mission-btn');
  if (startBtn) {
    startBtn.addEventListener('click', function() {
      if (phase === 'instructions') {
        startGame();
      }
    });
    // Hover effect
    startBtn.addEventListener('mouseenter', function() {
      this.style.transform = 'scale(1.05)';
      this.style.boxShadow = '0 6px 20px rgba(200,16,46,0.6), 0 0 30px rgba(200,16,46,0.3) inset';
    });
    startBtn.addEventListener('mouseleave', function() {
      this.style.transform = 'scale(1)';
      this.style.boxShadow = '0 4px 15px rgba(200,16,46,0.4), 0 0 20px rgba(200,16,46,0.2) inset';
    });
  }
});

// Resize
window.addEventListener('resize', () => scene.resize());

// ── BOOT ──
requestAnimationFrame(gameLoop);
doLoad();

})();
</script>
</body>
</html>
